package main

import (
	"encoding/json"
	"log"
	"net/http"
	"time"

	"github.com/gomodule/redigo/redis"
	"github.com/karlseguin/ccache/v3"
)

/*
Cache with max size 500 (10% of DB),
prunes 100 elements at once (Bottom 10% of cache, shown to be faster),
and promotion threshold of 3 (doesn't promote after EVERY fetch)
*/
var cache = ccache.New(ccache.Configure[int]().MaxSize(500).ItemsToPrune(50))

var pool = newPool()

func newPool() *redis.Pool {
	return &redis.Pool{
		Dial: func() (redis.Conn, error) {
			c, err := redis.Dial("tcp", "redis-stack:6379")
			if err != nil {
				panic(err.Error())
			}
			return c, err
		},
	}
}

// Helper functions

func encodeJsonResp(w http.ResponseWriter, resp map[string]bool) {
	encoder := json.NewEncoder(w)
	encoder.Encode(resp)
}

func deleteIfCachedValueConflicts(url string) {

	cached := cache.GetWithoutPromote(url)
	if cached != nil && cached.Value() == 1 { // If value in cache and cached as "safe", then delete
		cache.Delete(url)
	}
}

func handleGetReq(w http.ResponseWriter, req *http.Request, resp map[string]bool) {

	// Isolate URL passed in
	url := req.URL.Path[12:]
	if req.URL.RawQuery != "" {
		url += "?" + req.URL.RawQuery
	}

	// Refer to README for description of caching strategy
	// Check if URL exists in Cache
	item := cache.Get(url)
	log.Println("CACHE: Checking for " + url + " in cache")
	if item == nil { // If Item not present in cache, get it from DB
		log.Println("CACHE: " + url + " Not present in cache")
		// Connect to DB
		client := pool.Get()
		defer client.Close()

		// Check if URL exists in DB
		exists, err := client.Do("GET", url)
		if err != nil {
			log.Println(err)
			http.Error(w, "DB: Error querying database.", http.StatusServiceUnavailable)
		}

		var isSafeBool bool = false
		var isSafeInt int = 0

		if exists == nil { // if not found in DB either
			isSafeBool = true
			isSafeInt = 1
		}

		resp["safe"] = isSafeBool
		cache.Set(url, isSafeInt, time.Hour)

	} else { // If it is in the cache
		log.Println("CACHE: " + url + " present in cache")

		if item.Value() == 0 {
			log.Println("CACHE: Cached value for " + url + " is 'unsafe' (0)")
			resp["safe"] = false

		} else if item.Value() == 1 {
			log.Println("CACHE: Cached value for " + url + " is 'safe' (1)")
			resp["safe"] = true

		} else {
			log.Fatal("CACHE: Invalid value found in Cache!")
			http.Error(w, "CACHE: Invalid value found in Cache.", http.StatusInternalServerError)
		}

	}
}

func handlePostReq(w http.ResponseWriter, req *http.Request, resp map[string]bool) {
	// Isolate URLs passed in
	urlMap := map[string][]string{}
	err := json.NewDecoder(req.Body).Decode(&urlMap)
	if err != nil {
		log.Println("HTTP: Error encountered while decoding request body")
		http.Error(w, err.Error(), http.StatusBadRequest)
		return
	}

	// Build MSET (insertion) query
	var pairs []interface{}
	for i := range urlMap["urls"] {
		deleteIfCachedValueConflicts(urlMap["urls"][i])
		pairs = append(pairs, urlMap["urls"][i], true)
	}

	// Connect to DB
	client := pool.Get()
	defer client.Close()

	// Insert URLs into the DB
	_, err = client.Do("MSET", pairs...)
	if err != nil {
		resp["success"] = false
		log.Println("DB: Error encountered while trying to insert data into database: " + err.Error())
		http.Error(w, "DB: Error inserting data into database", http.StatusServiceUnavailable)
	}
}

func handler(w http.ResponseWriter, req *http.Request) {

	w.Header().Set("Content-Type", "application/json")

	// TODO: Sanitize/Validate URL
	if req.Method == "GET" {

		log.Println("HTTP: Received GET request")
		resp := map[string]bool{"safe": false}

		handleGetReq(w, req, resp)

		// Send reply with JSON body
		encodeJsonResp(w, resp)

	} else if req.Method == "POST" {

		log.Println("HTTP: Received POST request")
		resp := map[string]bool{"success": true}

		handlePostReq(w, req, resp)

		// Send reply with JSON body
		encodeJsonResp(w, resp)

	} else {
		http.Error(w, "HTTP: Request method must be GET or POST. Refer to API docs for more info.", http.StatusMethodNotAllowed)
	}
}

func main() {

	http.HandleFunc("/v1/urlinfo/", handler)
	http.ListenAndServe(":8080", nil)

}
