package main

import (
	"encoding/json"
	"log"
	"net/http"
	"time"

	"github.com/gomodule/redigo/redis"
	"github.com/karlseguin/ccache/v3"
)

/*
Cache with max size 500 (10% of DB),
prunes 100 elements at once (Bottom 10% of cache, shown to be faster),
and promotion threshold of 3 (doesn't promote after EVERY fetch)
*/
var cache = ccache.New(ccache.Configure[int]().MaxSize(500).ItemsToPrune(50))

var pool = newPool()

func newPool() *redis.Pool {
	return &redis.Pool{
		Dial: func() (redis.Conn, error) {
			c, err := redis.Dial("tcp", ":6379")
			if err != nil {
				panic(err.Error())
			}
			return c, err
		},
	}
}

func encodeJsonResp(w http.ResponseWriter, resp map[string]bool) {
	encoder := json.NewEncoder(w)
	encoder.Encode(resp)
}

func handler(w http.ResponseWriter, req *http.Request) {

	w.Header().Set("Content-Type", "application/json")

	// TODO: Sanitize/Validate URL
	if req.Method == "GET" {

		log.Println("Received GET request")
		resp := map[string]bool{"safe": false}

		// Isolate URL passed in
		url := req.URL.Path[12:]
		if req.URL.RawQuery != "" {
			url += "?" + req.URL.RawQuery
		}

		/* There is some nuance to this cache.
		You'll notice we are only storing the URLs which are a known source of Malware,
		HOWEVER to truly optimize the system, the cache should also contain commonly requested
		NON-malicious URLs, since this will help to reduce latency for frequently accessed "safe" URLs.

		A further optimizaiton may be possible for example with different caches for valid and invalid URLs,
		since depending on the source of the URLs, it may be more common for a URL to be malicious or non-malicious,
		and therefore out-compete those of the other type in the cache.
		*/

		//Check if URL exists in Cache
		item := cache.Get(url)
		if item == nil { // If Item not present in cache, get it from DB

			// Connect to DB
			client := pool.Get()
			defer client.Close()

			// Check if URL exists in DB
			exists, err := client.Do("GET", url)
			if err != nil {
				log.Println(err)
			}

			var isSafeBool bool = false
			var isSafeInt int = 0

			if exists == nil { // if not found in DB either
				isSafeBool = true
				isSafeInt = 1
			}

			resp["safe"] = isSafeBool
			cache.Set(url, isSafeInt, time.Hour)

		} else { // If it is in the cache

			if item.Value() == 0 {
				resp["safe"] = false
			} else if item.Value() == 1 {
				resp["safe"] = true
			} else {
				log.Fatal("Invalid value found in Cache!")
			}

		}

		// Send reply with JSON body
		encodeJsonResp(w, resp)

	} else if req.Method == "POST" {

		log.Println("Received POST request")
		resp := map[string]bool{"success": true}

		// Isolate URLs passed in
		urlMap := map[string][]string{}
		err := json.NewDecoder(req.Body).Decode(&urlMap)
		if err != nil {
			http.Error(w, err.Error(), http.StatusBadRequest)
			return
		}

		// Build MSET (insertion) query
		var pairs []interface{}
		for i := range urlMap["urls"] {
			pairs = append(pairs, urlMap["urls"][i], true)
		}

		// Connect to DB
		client := pool.Get()
		defer client.Close()

		// Insert URLs into the DB
		_, err = client.Do("MSET", pairs...)
		if err != nil {
			resp["success"] = false
			log.Println(err)
		}

		// Send reply with JSON body
		encodeJsonResp(w, resp)

	} else {
		http.Error(w, "Method must be GET or POST. Refer to API docs for more info.", http.StatusMethodNotAllowed)
	}
}

func main() {

	http.HandleFunc("/v1/urlinfo/", handler)
	http.ListenAndServe(":8080", nil)

}
